//! S2: SBOM scan -> AlertEvent E2E tests.
//!
//! Validates that the SBOM scanner correctly discovers vulnerabilities
//! and converts them to AlertEvents routed through the alert channel.

use std::io::Write;

use crate::helpers::assertions::*;

use ironpost_core::event::MODULE_SBOM_SCANNER;
use ironpost_core::pipeline::Pipeline;
use ironpost_core::types::Severity;
use ironpost_sbom_scanner::{SbomFormat, SbomScannerBuilder, SbomScannerConfig};

/// Helper: Create a temporary directory with a Cargo.lock file.
///
/// Returns the temp directory (which must be kept alive) and the directory path.
fn create_temp_cargo_lock(packages: &[(&str, &str)]) -> (tempfile::TempDir, String) {
    let temp_dir = tempfile::TempDir::new().expect("failed to create temp directory");
    let lockfile_path = temp_dir.path().join("Cargo.lock");

    let mut file = std::fs::File::create(&lockfile_path).expect("failed to create Cargo.lock");
    writeln!(file, "# This file is automatically @generated by Cargo.")
        .expect("failed to write header");
    writeln!(file).expect("failed to write blank line");

    for (name, version) in packages {
        writeln!(file, "[[package]]").expect("failed to write package");
        writeln!(file, "name = \"{}\"", name).expect("failed to write name");
        writeln!(file, "version = \"{}\"", version).expect("failed to write version");
        writeln!(
            file,
            "source = \"registry+https://github.com/rust-lang/crates.io-index\""
        )
        .expect("failed to write source");
        writeln!(file, "checksum = \"abc123def456\"").expect("failed to write checksum");
        writeln!(file, "dependencies = []").expect("failed to write dependencies");
        writeln!(file).expect("failed to write blank line");
    }

    use std::io::Write;
    file.flush().expect("failed to flush Cargo.lock");
    drop(file); // Close the file

    let dir_path = temp_dir.path().to_string_lossy().to_string();
    (temp_dir, dir_path)
}

/// Helper: Create a temporary vulnerability database JSON file.
fn create_temp_vuln_db(entries: &[(&str, &str, &str, &str, &str)]) -> tempfile::NamedTempFile {
    let mut file = tempfile::NamedTempFile::new().expect("failed to create temp vuln DB");
    writeln!(file, "[").expect("failed to write opening bracket");

    for (idx, (cve_id, package, introduced, fixed, severity)) in entries.iter().enumerate() {
        let comma = if idx < entries.len() - 1 { "," } else { "" };
        let entry = format!(
            r#"  {{
    "cve_id": "{}",
    "package": "{}",
    "ecosystem": "Cargo",
    "affected_ranges": [
      {{
        "introduced": "{}",
        "fixed": "{}"
      }}
    ],
    "fixed_version": "{}",
    "severity": "{}",
    "description": "Test vulnerability {}",
    "published": "2024-01-01"
  }}{}"#,
            cve_id, package, introduced, fixed, fixed, severity, cve_id, comma
        );
        writeln!(file, "{}", entry).expect("failed to write vuln entry");
    }

    writeln!(file, "]").expect("failed to write closing bracket");
    file.flush().expect("failed to flush vuln DB");
    file
}

/// Helper: Create a temporary directory and copy the vuln DB file into it as `cargo.json`.
fn setup_vuln_db_dir(vuln_db_file: &tempfile::NamedTempFile) -> tempfile::TempDir {
    let temp_dir = tempfile::TempDir::new().expect("failed to create temp vuln DB directory");
    let cargo_db_path = temp_dir.path().join("cargo.json");
    std::fs::copy(vuln_db_file.path(), &cargo_db_path).expect("failed to copy vuln DB");
    temp_dir
}

// ---------------------------------------------------------------------------
// E2E SBOM Scan Tests
// ---------------------------------------------------------------------------

/// SBOM scanner finds a known vulnerable package -> AlertEvent generated
/// with correct CVE ID and severity.
#[tokio::test]
async fn test_e2e_sbom_scan_vuln_found_alert() {
    // 1. Create temp Cargo.lock with a vulnerable package
    let (_lockfile_dir_guard, lockfile_dir) =
        create_temp_cargo_lock(&[("vulnerable-pkg", "1.0.0")]);

    // 2. Create temp vuln DB with CVE matching the package
    let vuln_db_file = create_temp_vuln_db(&[(
        "CVE-2024-9999",
        "vulnerable-pkg",
        "1.0.0",
        "1.1.0",
        "Critical",
    )]);
    let vuln_db_dir = setup_vuln_db_dir(&vuln_db_file);
    let vuln_db_path = vuln_db_dir.path().to_string_lossy().to_string();

    // 3. Configure SBOM scanner
    let config = SbomScannerConfig {
        enabled: true,
        scan_dirs: vec![lockfile_dir],
        vuln_db_path,
        min_severity: Severity::Info,
        output_format: SbomFormat::CycloneDx,
        scan_interval_secs: 0, // Manual scan only
        max_file_size: 10 * 1024 * 1024,
        max_packages: 10000,
    };

    let (mut scanner, alert_rx_opt) = SbomScannerBuilder::new().config(config).build().unwrap();
    let mut alert_rx = alert_rx_opt.expect("should have alert channel");

    // 4. Start scanner and run scan
    scanner.start().await.unwrap();
    assert!(scanner.is_vuln_db_loaded(), "should load vuln DB");

    scanner.scan_once().await.unwrap();

    // 5. Assert AlertEvent received with CVE info
    let alert_event = assert_received_within(&mut alert_rx, DEFAULT_TIMEOUT).await;
    assert_eq!(
        alert_event.severity,
        Severity::Critical,
        "should match CVE severity"
    );
    assert!(
        alert_event.alert.title.contains("CVE-2024-9999"),
        "alert title should contain CVE ID"
    );
    assert_eq!(
        alert_event.metadata.source_module, MODULE_SBOM_SCANNER,
        "source_module should be sbom-scanner"
    );

    scanner.stop().await.unwrap();
}

/// Clean project with no vulnerabilities -> no AlertEvent generated.
#[tokio::test]
async fn test_e2e_sbom_scan_clean_no_alert() {
    // 1. Create temp Cargo.lock with only safe packages
    let (_lockfile_dir_guard, lockfile_dir) = create_temp_cargo_lock(&[("safe-pkg", "2.0.0")]);

    // 2. Create temp vuln DB with CVE for a different package
    let vuln_db_file =
        create_temp_vuln_db(&[("CVE-2024-8888", "vulnerable-pkg", "1.0.0", "1.1.0", "High")]);
    let vuln_db_dir = setup_vuln_db_dir(&vuln_db_file);
    let vuln_db_path = vuln_db_dir.path().to_string_lossy().to_string();

    // 3. Configure SBOM scanner
    let config = SbomScannerConfig {
        enabled: true,
        scan_dirs: vec![lockfile_dir],
        vuln_db_path,
        min_severity: Severity::Info,
        output_format: SbomFormat::CycloneDx,
        scan_interval_secs: 0,
        max_file_size: 10 * 1024 * 1024,
        max_packages: 10000,
    };

    let (mut scanner, alert_rx_opt) = SbomScannerBuilder::new().config(config).build().unwrap();
    let mut alert_rx = alert_rx_opt.expect("should have alert channel");

    // 4. Start scanner and run scan
    scanner.start().await.unwrap();
    scanner.scan_once().await.unwrap();

    // 5. Assert no AlertEvent within SHORT_TIMEOUT
    assert_not_received_within(&mut alert_rx, SHORT_TIMEOUT).await;

    scanner.stop().await.unwrap();
}

/// Multiple vulnerabilities -> one AlertEvent per vulnerability.
#[tokio::test]
async fn test_e2e_sbom_scan_multiple_vulns() {
    // 1. Create lockfile with 3 vulnerable packages
    let (_lockfile_dir_guard, lockfile_dir) = create_temp_cargo_lock(&[
        ("vuln-pkg-a", "1.0.0"),
        ("vuln-pkg-b", "2.0.0"),
        ("vuln-pkg-c", "3.0.0"),
    ]);

    // 2. Create temp vuln DB with 3 CVEs
    let vuln_db_file = create_temp_vuln_db(&[
        ("CVE-2024-0001", "vuln-pkg-a", "1.0.0", "1.1.0", "High"),
        ("CVE-2024-0002", "vuln-pkg-b", "2.0.0", "2.1.0", "Medium"),
        ("CVE-2024-0003", "vuln-pkg-c", "3.0.0", "3.1.0", "Critical"),
    ]);
    let vuln_db_dir = setup_vuln_db_dir(&vuln_db_file);
    let vuln_db_path = vuln_db_dir.path().to_string_lossy().to_string();

    // 3. Configure SBOM scanner
    let config = SbomScannerConfig {
        enabled: true,
        scan_dirs: vec![lockfile_dir],
        vuln_db_path,
        min_severity: Severity::Info,
        output_format: SbomFormat::CycloneDx,
        scan_interval_secs: 0,
        max_file_size: 10 * 1024 * 1024,
        max_packages: 10000,
    };

    let (mut scanner, alert_rx_opt) = SbomScannerBuilder::new().config(config).build().unwrap();
    let mut alert_rx = alert_rx_opt.expect("should have alert channel");

    // 4. Start scanner and run scan
    scanner.start().await.unwrap();
    scanner.scan_once().await.unwrap();

    // 5. Collect all alerts
    let alerts = collect_within(&mut alert_rx, DEFAULT_TIMEOUT).await;

    // 6. Assert 3 AlertEvents received
    assert_eq!(
        alerts.len(),
        3,
        "should receive 3 AlertEvents, got {} alerts with titles: {:?}",
        alerts.len(),
        alerts.iter().map(|a| &a.alert.title).collect::<Vec<_>>()
    );

    let cve_ids: Vec<String> = alerts
        .iter()
        .map(|a| {
            // Extract CVE ID from title - handle different title formats
            a.alert
                .title
                .split_whitespace()
                .find(|s| s.starts_with("CVE-"))
                .map(|s| s.trim_end_matches(':').to_owned())
                .unwrap_or_else(|| {
                    tracing::debug!("Could not extract CVE from title: {}", a.alert.title);
                    String::new()
                })
        })
        .collect();

    tracing::debug!("Extracted CVE IDs: {:?}", cve_ids);

    assert!(
        cve_ids.contains(&"CVE-2024-0001".to_owned()),
        "should find CVE-2024-0001, got: {:?}",
        cve_ids
    );
    assert!(
        cve_ids.contains(&"CVE-2024-0002".to_owned()),
        "should find CVE-2024-0002, got: {:?}",
        cve_ids
    );
    assert!(
        cve_ids.contains(&"CVE-2024-0003".to_owned()),
        "should find CVE-2024-0003, got: {:?}",
        cve_ids
    );

    scanner.stop().await.unwrap();
}

/// Vulnerability severity is correctly mapped to AlertEvent severity.
#[tokio::test]
async fn test_e2e_sbom_alert_severity_mapping() {
    // 1. Create lockfile with packages of various severities
    let (_lockfile_dir_guard, lockfile_dir) = create_temp_cargo_lock(&[
        ("crit-pkg", "1.0.0"),
        ("high-pkg", "1.0.0"),
        ("med-pkg", "1.0.0"),
    ]);

    // 2. Create vulns with CRITICAL, HIGH, MEDIUM severities
    let vuln_db_file = create_temp_vuln_db(&[
        ("CVE-CRIT", "crit-pkg", "1.0.0", "1.1.0", "Critical"),
        ("CVE-HIGH", "high-pkg", "1.0.0", "1.1.0", "High"),
        ("CVE-MED", "med-pkg", "1.0.0", "1.1.0", "Medium"),
    ]);
    let vuln_db_dir = setup_vuln_db_dir(&vuln_db_file);
    let vuln_db_path = vuln_db_dir.path().to_string_lossy().to_string();

    // 3. Configure SBOM scanner
    let config = SbomScannerConfig {
        enabled: true,
        scan_dirs: vec![lockfile_dir],
        vuln_db_path,
        min_severity: Severity::Info,
        output_format: SbomFormat::CycloneDx,
        scan_interval_secs: 0,
        max_file_size: 10 * 1024 * 1024,
        max_packages: 10000,
    };

    let (mut scanner, alert_rx_opt) = SbomScannerBuilder::new().config(config).build().unwrap();
    let mut alert_rx = alert_rx_opt.expect("should have alert channel");

    // 4. Start scanner and run scan
    scanner.start().await.unwrap();
    scanner.scan_once().await.unwrap();

    // 5. Collect all alerts
    let alerts = collect_within(&mut alert_rx, DEFAULT_TIMEOUT).await;
    assert_eq!(alerts.len(), 3, "should receive 3 alerts");

    // 6. Assert each AlertEvent has corresponding severity
    let mut found_critical = false;
    let mut found_high = false;
    let mut found_medium = false;

    for alert in &alerts {
        if alert.alert.title.contains("CVE-CRIT") {
            assert_eq!(
                alert.severity,
                Severity::Critical,
                "CVE-CRIT should have Critical severity"
            );
            found_critical = true;
        } else if alert.alert.title.contains("CVE-HIGH") {
            assert_eq!(
                alert.severity,
                Severity::High,
                "CVE-HIGH should have High severity"
            );
            found_high = true;
        } else if alert.alert.title.contains("CVE-MED") {
            assert_eq!(
                alert.severity,
                Severity::Medium,
                "CVE-MED should have Medium severity"
            );
            found_medium = true;
        }
    }

    assert!(found_critical, "should find Critical alert");
    assert!(found_high, "should find High alert");
    assert!(found_medium, "should find Medium alert");

    scanner.stop().await.unwrap();
}

/// SBOM AlertEvent has source_module == "sbom-scanner".
#[tokio::test]
async fn test_e2e_sbom_alert_source_module() {
    // 1. Create lockfile with a vulnerable package
    let (_lockfile_dir_guard, lockfile_dir) = create_temp_cargo_lock(&[("test-pkg", "1.0.0")]);

    // 2. Create temp vuln DB
    let vuln_db_file =
        create_temp_vuln_db(&[("CVE-2024-SRC", "test-pkg", "1.0.0", "1.1.0", "High")]);
    let vuln_db_dir = setup_vuln_db_dir(&vuln_db_file);
    let vuln_db_path = vuln_db_dir.path().to_string_lossy().to_string();

    // 3. Configure SBOM scanner
    let config = SbomScannerConfig {
        enabled: true,
        scan_dirs: vec![lockfile_dir],
        vuln_db_path,
        min_severity: Severity::Info,
        output_format: SbomFormat::CycloneDx,
        scan_interval_secs: 0,
        max_file_size: 10 * 1024 * 1024,
        max_packages: 10000,
    };

    let (mut scanner, alert_rx_opt) = SbomScannerBuilder::new().config(config).build().unwrap();
    let mut alert_rx = alert_rx_opt.expect("should have alert channel");

    // 4. Start scanner and run scan
    scanner.start().await.unwrap();
    scanner.scan_once().await.unwrap();

    // 5. Assert metadata.source_module == MODULE_SBOM_SCANNER
    let alert_event = assert_received_within(&mut alert_rx, DEFAULT_TIMEOUT).await;
    assert_eq!(
        alert_event.metadata.source_module, MODULE_SBOM_SCANNER,
        "source_module should be '{}' but got '{}'",
        MODULE_SBOM_SCANNER, alert_event.metadata.source_module
    );

    scanner.stop().await.unwrap();
}
