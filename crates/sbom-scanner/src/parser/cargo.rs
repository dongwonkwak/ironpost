//! Cargo.lock 파서
//!
//! [`CargoLockParser`]는 Rust의 Cargo.lock (TOML v3) 파일을 파싱하여
//! [`PackageGraph`]를 생성합니다.
//!
//! # Cargo.lock 형식 예시
//!
//! ```toml
//! [[package]]
//! name = "serde"
//! version = "1.0.204"
//! source = "registry+https://github.com/rust-lang/crates.io-index"
//! checksum = "abc..."
//! dependencies = [
//!     "serde_derive",
//! ]
//! ```

use std::path::Path;

use serde::Deserialize;

use crate::error::SbomScannerError;
use crate::parser::LockfileParser;
use crate::types::{Ecosystem, Package, PackageGraph};

/// Cargo.lock 파서
///
/// TOML 형식의 Cargo.lock 파일을 파싱합니다.
pub struct CargoLockParser;

/// Cargo.lock TOML 구조 (파싱용)
#[derive(Deserialize)]
struct CargoLockFile {
    #[serde(default)]
    package: Vec<CargoLockPackage>,
}

/// Cargo.lock 내 개별 패키지 (파싱용)
#[derive(Deserialize)]
struct CargoLockPackage {
    name: String,
    version: String,
    #[serde(default)]
    source: Option<String>,
    #[serde(default)]
    checksum: Option<String>,
    #[serde(default)]
    dependencies: Vec<String>,
}

impl LockfileParser for CargoLockParser {
    fn ecosystem(&self) -> Ecosystem {
        Ecosystem::Cargo
    }

    fn can_parse(&self, path: &Path) -> bool {
        path.file_name()
            .and_then(|n| n.to_str())
            .is_some_and(|name| name == "Cargo.lock")
    }

    fn parse(
        &self,
        content: &str,
        source_path: &str,
    ) -> Result<PackageGraph, SbomScannerError> {
        let lock_file: CargoLockFile = toml::from_str(content).map_err(|e| {
            SbomScannerError::LockfileParse {
                path: source_path.to_owned(),
                reason: e.to_string(),
            }
        })?;

        let mut packages = Vec::with_capacity(lock_file.package.len());
        let mut root_packages = Vec::new();

        for entry in &lock_file.package {
            let purl = Package::make_purl(&Ecosystem::Cargo, &entry.name, &entry.version);

            // 패키지 의존성에서 이름만 추출 (Cargo.lock의 deps는 "name version" 형식)
            let deps: Vec<String> = entry
                .dependencies
                .iter()
                .map(|d| {
                    d.split_whitespace()
                        .next()
                        .unwrap_or(d)
                        .to_owned()
                })
                .collect();

            // source가 없으면 로컬(루트) 패키지
            if entry.source.is_none() {
                root_packages.push(entry.name.clone());
            }

            packages.push(Package {
                name: entry.name.clone(),
                version: entry.version.clone(),
                ecosystem: Ecosystem::Cargo,
                purl,
                checksum: entry.checksum.clone(),
                dependencies: deps,
            });
        }

        Ok(PackageGraph {
            source_file: source_path.to_owned(),
            ecosystem: Ecosystem::Cargo,
            packages,
            root_packages,
        })
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    const SAMPLE_CARGO_LOCK: &str = r#"
# This file is automatically @generated by Cargo.

[[package]]
name = "my-app"
version = "0.1.0"
dependencies = [
    "serde",
    "tokio",
]

[[package]]
name = "serde"
version = "1.0.204"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "abc123"
dependencies = [
    "serde_derive",
]

[[package]]
name = "serde_derive"
version = "1.0.204"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "def456"

[[package]]
name = "tokio"
version = "1.38.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "ghi789"
"#;

    #[test]
    fn can_parse_cargo_lock() {
        let parser = CargoLockParser;
        assert!(parser.can_parse(Path::new("Cargo.lock")));
        assert!(parser.can_parse(Path::new("/project/Cargo.lock")));
        assert!(!parser.can_parse(Path::new("package-lock.json")));
        assert!(!parser.can_parse(Path::new("Cargo.toml")));
    }

    #[test]
    fn parse_sample_cargo_lock() {
        let parser = CargoLockParser;
        let graph = parser.parse(SAMPLE_CARGO_LOCK, "Cargo.lock").unwrap();

        assert_eq!(graph.ecosystem, Ecosystem::Cargo);
        assert_eq!(graph.source_file, "Cargo.lock");
        assert_eq!(graph.packages.len(), 4);
        assert_eq!(graph.root_packages, vec!["my-app"]);

        // Verify serde package
        let serde = graph.find_package("serde").unwrap();
        assert_eq!(serde.version, "1.0.204");
        assert_eq!(serde.purl, "pkg:cargo/serde@1.0.204");
        assert_eq!(serde.checksum.as_deref(), Some("abc123"));
        assert_eq!(serde.dependencies, vec!["serde_derive"]);
    }

    #[test]
    fn parse_empty_cargo_lock() {
        let parser = CargoLockParser;
        let graph = parser.parse("", "Cargo.lock").unwrap();
        assert_eq!(graph.packages.len(), 0);
    }

    #[test]
    fn parse_invalid_toml_returns_error() {
        let parser = CargoLockParser;
        let result = parser.parse("invalid = [[[toml", "Cargo.lock");
        assert!(result.is_err());
        if let Err(SbomScannerError::LockfileParse { path, .. }) = result {
            assert_eq!(path, "Cargo.lock");
        } else {
            panic!("expected LockfileParse error");
        }
    }

    #[test]
    fn ecosystem_is_cargo() {
        let parser = CargoLockParser;
        assert_eq!(parser.ecosystem(), Ecosystem::Cargo);
    }

    #[test]
    fn root_packages_have_no_source() {
        let parser = CargoLockParser;
        let graph = parser.parse(SAMPLE_CARGO_LOCK, "Cargo.lock").unwrap();
        // my-app has no source field -> root package
        assert!(graph.root_packages.contains(&"my-app".to_owned()));
        // serde has source -> not root
        assert!(!graph.root_packages.contains(&"serde".to_owned()));
    }

    // Edge case tests

    #[test]
    fn parse_malformed_toml_missing_brackets() {
        let parser = CargoLockParser;
        let malformed = r#"
package
name = "test"
version = "1.0.0"
"#;
        let result = parser.parse(malformed, "Cargo.lock");
        assert!(result.is_err());
        match result {
            Err(SbomScannerError::LockfileParse { path, .. }) => {
                assert_eq!(path, "Cargo.lock");
            }
            _ => panic!("expected LockfileParse error"),
        }
    }

    #[test]
    fn parse_corrupted_toml_invalid_syntax() {
        let parser = CargoLockParser;
        let corrupted = "[[package]]\nname = 'unclosed string";
        let result = parser.parse(corrupted, "/path/to/Cargo.lock");
        assert!(result.is_err());
    }

    #[test]
    fn parse_cargo_lock_with_very_long_package_name() {
        let parser = CargoLockParser;
        let long_name = "a".repeat(1000);
        let lockfile = format!(
            r#"
[[package]]
name = "{}"
version = "1.0.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
"#,
            long_name
        );
        let graph = parser.parse(&lockfile, "Cargo.lock").unwrap();
        assert_eq!(graph.packages.len(), 1);
        assert_eq!(graph.packages[0].name.len(), 1000);
    }

    #[test]
    fn parse_cargo_lock_with_very_long_version() {
        let parser = CargoLockParser;
        let long_version = "1.".to_owned() + &"0".repeat(500);
        let lockfile = format!(
            r#"
[[package]]
name = "test-pkg"
version = "{}"
source = "registry+https://github.com/rust-lang/crates.io-index"
"#,
            long_version
        );
        let graph = parser.parse(&lockfile, "Cargo.lock").unwrap();
        assert_eq!(graph.packages.len(), 1);
        assert_eq!(graph.packages[0].version, long_version);
    }

    #[test]
    fn parse_cargo_lock_duplicate_packages() {
        let parser = CargoLockParser;
        let lockfile = r#"
[[package]]
name = "duplicate-pkg"
version = "1.0.0"
source = "registry+https://github.com/rust-lang/crates.io-index"

[[package]]
name = "duplicate-pkg"
version = "2.0.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
"#;
        let graph = parser.parse(lockfile, "Cargo.lock").unwrap();
        // Both versions should be parsed
        assert_eq!(graph.packages.len(), 2);
        let versions: Vec<&str> = graph.packages.iter().map(|p| p.version.as_str()).collect();
        assert!(versions.contains(&"1.0.0"));
        assert!(versions.contains(&"2.0.0"));
    }

    #[test]
    fn parse_cargo_lock_no_packages() {
        let parser = CargoLockParser;
        let lockfile = "# Empty lockfile\n";
        let graph = parser.parse(lockfile, "Cargo.lock").unwrap();
        assert_eq!(graph.packages.len(), 0);
        assert_eq!(graph.root_packages.len(), 0);
    }

    #[test]
    fn parse_cargo_lock_special_characters_in_name() {
        let parser = CargoLockParser;
        let lockfile = r#"
[[package]]
name = "pkg-with_special.chars"
version = "1.0.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
"#;
        let graph = parser.parse(lockfile, "Cargo.lock").unwrap();
        assert_eq!(graph.packages.len(), 1);
        assert_eq!(graph.packages[0].name, "pkg-with_special.chars");
    }

    #[test]
    fn parse_cargo_lock_dependency_with_version_spec() {
        let parser = CargoLockParser;
        let lockfile = r#"
[[package]]
name = "my-app"
version = "0.1.0"
dependencies = [
    "serde 1.0.204",
    "tokio 1.38.0 (registry+https://github.com/rust-lang/crates.io-index)",
]
"#;
        let graph = parser.parse(lockfile, "Cargo.lock").unwrap();
        assert_eq!(graph.packages.len(), 1);
        // Dependencies should have names extracted (without version)
        assert_eq!(graph.packages[0].dependencies, vec!["serde", "tokio"]);
    }

    #[test]
    fn parse_cargo_lock_no_dependencies_field() {
        let parser = CargoLockParser;
        let lockfile = r#"
[[package]]
name = "standalone"
version = "1.0.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
"#;
        let graph = parser.parse(lockfile, "Cargo.lock").unwrap();
        assert_eq!(graph.packages.len(), 1);
        assert!(graph.packages[0].dependencies.is_empty());
    }

    #[test]
    fn parse_cargo_lock_unicode_in_name() {
        let parser = CargoLockParser;
        let lockfile = r#"
[[package]]
name = "日本語-パッケージ"
version = "1.0.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
"#;
        let graph = parser.parse(lockfile, "Cargo.lock").unwrap();
        assert_eq!(graph.packages.len(), 1);
        assert_eq!(graph.packages[0].name, "日本語-パッケージ");
    }
}
