//! Cargo.lock 파서
//!
//! [`CargoLockParser`]는 Rust의 Cargo.lock (TOML v3) 파일을 파싱하여
//! [`PackageGraph`]를 생성합니다.
//!
//! # Cargo.lock 형식 예시
//!
//! ```toml
//! [[package]]
//! name = "serde"
//! version = "1.0.204"
//! source = "registry+https://github.com/rust-lang/crates.io-index"
//! checksum = "abc..."
//! dependencies = [
//!     "serde_derive",
//! ]
//! ```

use std::path::Path;

use serde::Deserialize;

use crate::error::SbomScannerError;
use crate::parser::LockfileParser;
use crate::types::{Ecosystem, Package, PackageGraph};

/// Cargo.lock 파서
///
/// TOML 형식의 Cargo.lock 파일을 파싱합니다.
pub struct CargoLockParser;

/// Cargo.lock TOML 구조 (파싱용)
#[derive(Deserialize)]
struct CargoLockFile {
    #[serde(default)]
    package: Vec<CargoLockPackage>,
}

/// Cargo.lock 내 개별 패키지 (파싱용)
#[derive(Deserialize)]
struct CargoLockPackage {
    name: String,
    version: String,
    #[serde(default)]
    source: Option<String>,
    #[serde(default)]
    checksum: Option<String>,
    #[serde(default)]
    dependencies: Vec<String>,
}

impl LockfileParser for CargoLockParser {
    fn ecosystem(&self) -> Ecosystem {
        Ecosystem::Cargo
    }

    fn can_parse(&self, path: &Path) -> bool {
        path.file_name()
            .and_then(|n| n.to_str())
            .is_some_and(|name| name == "Cargo.lock")
    }

    fn parse(
        &self,
        content: &str,
        source_path: &str,
    ) -> Result<PackageGraph, SbomScannerError> {
        let lock_file: CargoLockFile = toml::from_str(content).map_err(|e| {
            SbomScannerError::LockfileParse {
                path: source_path.to_owned(),
                reason: e.to_string(),
            }
        })?;

        let mut packages = Vec::with_capacity(lock_file.package.len());
        let mut root_packages = Vec::new();

        for entry in &lock_file.package {
            let purl = Package::make_purl(&Ecosystem::Cargo, &entry.name, &entry.version);

            // 패키지 의존성에서 이름만 추출 (Cargo.lock의 deps는 "name version" 형식)
            let deps: Vec<String> = entry
                .dependencies
                .iter()
                .map(|d| {
                    d.split_whitespace()
                        .next()
                        .unwrap_or(d)
                        .to_owned()
                })
                .collect();

            // source가 없으면 로컬(루트) 패키지
            if entry.source.is_none() {
                root_packages.push(entry.name.clone());
            }

            packages.push(Package {
                name: entry.name.clone(),
                version: entry.version.clone(),
                ecosystem: Ecosystem::Cargo,
                purl,
                checksum: entry.checksum.clone(),
                dependencies: deps,
            });
        }

        Ok(PackageGraph {
            source_file: source_path.to_owned(),
            ecosystem: Ecosystem::Cargo,
            packages,
            root_packages,
        })
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    const SAMPLE_CARGO_LOCK: &str = r#"
# This file is automatically @generated by Cargo.

[[package]]
name = "my-app"
version = "0.1.0"
dependencies = [
    "serde",
    "tokio",
]

[[package]]
name = "serde"
version = "1.0.204"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "abc123"
dependencies = [
    "serde_derive",
]

[[package]]
name = "serde_derive"
version = "1.0.204"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "def456"

[[package]]
name = "tokio"
version = "1.38.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "ghi789"
"#;

    #[test]
    fn can_parse_cargo_lock() {
        let parser = CargoLockParser;
        assert!(parser.can_parse(Path::new("Cargo.lock")));
        assert!(parser.can_parse(Path::new("/project/Cargo.lock")));
        assert!(!parser.can_parse(Path::new("package-lock.json")));
        assert!(!parser.can_parse(Path::new("Cargo.toml")));
    }

    #[test]
    fn parse_sample_cargo_lock() {
        let parser = CargoLockParser;
        let graph = parser.parse(SAMPLE_CARGO_LOCK, "Cargo.lock").unwrap();

        assert_eq!(graph.ecosystem, Ecosystem::Cargo);
        assert_eq!(graph.source_file, "Cargo.lock");
        assert_eq!(graph.packages.len(), 4);
        assert_eq!(graph.root_packages, vec!["my-app"]);

        // Verify serde package
        let serde = graph.find_package("serde").unwrap();
        assert_eq!(serde.version, "1.0.204");
        assert_eq!(serde.purl, "pkg:cargo/serde@1.0.204");
        assert_eq!(serde.checksum.as_deref(), Some("abc123"));
        assert_eq!(serde.dependencies, vec!["serde_derive"]);
    }

    #[test]
    fn parse_empty_cargo_lock() {
        let parser = CargoLockParser;
        let graph = parser.parse("", "Cargo.lock").unwrap();
        assert_eq!(graph.packages.len(), 0);
    }

    #[test]
    fn parse_invalid_toml_returns_error() {
        let parser = CargoLockParser;
        let result = parser.parse("invalid = [[[toml", "Cargo.lock");
        assert!(result.is_err());
        if let Err(SbomScannerError::LockfileParse { path, .. }) = result {
            assert_eq!(path, "Cargo.lock");
        } else {
            panic!("expected LockfileParse error");
        }
    }

    #[test]
    fn ecosystem_is_cargo() {
        let parser = CargoLockParser;
        assert_eq!(parser.ecosystem(), Ecosystem::Cargo);
    }

    #[test]
    fn root_packages_have_no_source() {
        let parser = CargoLockParser;
        let graph = parser.parse(SAMPLE_CARGO_LOCK, "Cargo.lock").unwrap();
        // my-app has no source field -> root package
        assert!(graph.root_packages.contains(&"my-app".to_owned()));
        // serde has source -> not root
        assert!(!graph.root_packages.contains(&"serde".to_owned()));
    }
}
